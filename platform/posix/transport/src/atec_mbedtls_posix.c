/* Standard includes. */
#include <assert.h>
#include <string.h>

/* POSIX socket include. */
#include <unistd.h>

/* Transport interface include. */
#include "transport_interface.h"

#include "atec_mbedtls_posix.h"

#if 0
#include "tngtls_cert_def_1_signer.h"
#include "tngtls_cert_def_3_device.h"
#endif 

/* This is the value used to secure the pre-master secret generated by ECDH on
    the device since it is being transfered over the bus */
uint8_t atca_io_protection_key[32] = {
    0x37, 0x80, 0xe6, 0x3d, 0x49, 0x68, 0xad, 0xe5,
    0xd8, 0x22, 0xc0, 0x13, 0xfc, 0xc3, 0x23, 0x84,
    0x5d, 0x1b, 0x56, 0x9f, 0xe7, 0x05, 0xb6, 0x00,
    0x06, 0xfe, 0xec, 0x14, 0x5a, 0x0d, 0xb1, 0xe3
};

int atca_mbedtls_ecdh_slot_cb(void)
{
    return 0xFFFF;
}

int atca_mbedtls_ecdh_ioprot_cb(uint8_t secret[32])
{
    memcpy(secret, atca_io_protection_key, 32);
    return 0;
}

static void my_debug(void *ctx, int level,
    const char *file, int line,
    const char *str)
{
    ((void)level);

    printf("%s:%04d: %s", file, line, str);
}

#if 1 
int atca_connect(const char * endpoint, const char * port)
{
    int ret;
    mbedtls_net_context server_fd;
    const char *pers = "ssl_client1";

    mbedtls_entropy_context entropy;
    mbedtls_ctr_drbg_context ctr_drbg;
    mbedtls_ssl_context ssl;
    mbedtls_ssl_config conf;
    mbedtls_x509_crt cacert;
    mbedtls_pk_context pkey;
    mbedtls_x509_crt cert;
    ATCA_STATUS status;

	 /* Start a session with the device */
	 if (ATCA_SUCCESS != (status = atcab_init(&cfg_ateccx08a_i2c_default)))
	 {
	     printf("Failed to init: %d\r\n", status);
         return -1;
	 }

    /*
    * 0. Initialize the RNG and the session data
    */
    mbedtls_net_init(&server_fd);
    mbedtls_ssl_init(&ssl);
    mbedtls_ssl_config_init(&conf);
    mbedtls_x509_crt_init(&cacert);
    mbedtls_x509_crt_init(&cert);
    mbedtls_ctr_drbg_init(&ctr_drbg);
    // mbedtls_debug_set_threshold(2);

    char out[1024];
    const mbedtls_x509_crt *peer;

    uint8_t random_num[32] = {};
    int fd, count;
#if 0 
    // Add entropy to the system
    atcab_random(random_num);
    count = 128;  //4bits/byte * 32 bytes
    fd = open("/dev/urandom", O_WRONLY);
    if (fd < 0) {
        perror("open(/dev/urandom)");
        exit(1);
    }
    if (ioctl(fd, RNDADDTOENTCNT, &count) < 0) {
        perror("ioctl(RNDADDTOENTCNT)");
        close(fd);
        exit(1);
    }
    close(fd);
    printf("Random Number: ");
    for(int i=0;i<32;i++) {
        printf("%x", random_num[i]);
    }
    printf("\n");
    // end add entropy
#endif 
    uint8_t pub_key[64] = {0};
    int i; 
    status = ATCA_GEN_FAIL;
    status = atcab_get_pubkey(0, pub_key);
    printf("Public Key Slot 0: ");
    for(i=0; i<64; i++) {
        printf("%02x", pub_key[i]);
    }
    printf("\n");

    printf("  . Setting the io_protection_key... ");
    fflush(stdout);

    status = ATCA_GEN_FAIL;
    if (ATCA_SUCCESS != atcab_write_zone(ATCA_ZONE_DATA, 6, 0, 0, atca_io_protection_key, ATCA_BLOCK_SIZE)) {
        printf("fail\n");
        goto exit;
    }
    printf("ok");
    fflush(stdout);

    printf("\n  . Seeding the random number generator...");
    fflush(stdout);

    mbedtls_entropy_init(&entropy);
    if ((ret = mbedtls_ctr_drbg_seed(&ctr_drbg, mbedtls_entropy_func, &entropy,
        (const unsigned char *)pers,
        strlen(pers))) != 0)
    {
        printf(" failed\n  ! mbedtls_ctr_drbg_seed returned %d\n", ret);
        goto exit;
    }

    printf(" ok\n");

    /* Set Up Defaults */
    printf("  . Setting up the SSL/TLS structure...");
    fflush(stdout);

    if ((ret = mbedtls_ssl_config_defaults(&conf,
        MBEDTLS_SSL_IS_CLIENT,
        MBEDTLS_SSL_TRANSPORT_STREAM,
        MBEDTLS_SSL_PRESET_DEFAULT)) != 0)
    {
        printf(" failed\n  ! mbedtls_ssl_config_defaults returned %d\n\n", ret);
        goto exit;
    }
    if (0 != mbedtls_x509_crt_parse_file(&cacert, "GG.crt")) {
        printf("Failed to parse ca from file\n");
    }
    mbedtls_ssl_conf_authmode(&conf, MBEDTLS_SSL_VERIFY_NONE);
    mbedtls_ssl_conf_ca_chain(&conf, &cacert, NULL);

    printf(" ok\n");

    /* Convert to an mbedtls key */
    if (0 != atca_mbedtls_pk_init(&pkey, 0))
    {
        printf("Failed to parse key from device\n");
        goto exit;
    }
#if 0 
    /* Extract the device certificate and convert to mbedtls cert */
    if (0 != atca_mbedtls_cert_add(&cert, &g_tngtls_cert_def_3_device))
    {
        printf("Failed to parse cert from device\n");
        goto exit;
    }

    /* Extract the signer certificate, convert, then attach to the chain */
    if (0 != atca_mbedtls_cert_add(&cert, &g_tngtls_cert_def_1_signer))
    {
        printf("Failed to parse cert from device\n\n");
        goto exit;
    }
#endif 
    mbedtls_x509_crt_info(out, sizeof(out), NULL, &cert);
    printf("\nDevice Certificate Info:\n%s\n", out);
    fflush(stdout);

    /* Attach the certificate chain and private key to the SSL/TLS context */
    printf("  . Set up the client credentials.");
    fflush(stdout);
    if(0 != (ret = mbedtls_ssl_conf_own_cert(
            &conf, &cert, &pkey)))
    {
        printf(" failed\n ! mbedtls_ssl_conf_own_cert returned %d\r\n", ret);
        goto exit;
    }
    printf(" ok\n");

    mbedtls_ssl_conf_authmode(&conf, MBEDTLS_SSL_VERIFY_OPTIONAL);
    mbedtls_ssl_conf_rng(&conf, mbedtls_ctr_drbg_random, &ctr_drbg);
    mbedtls_ssl_conf_dbg(&conf, my_debug, stdout);

    /* Set up the "ssl" session */
    if ((ret = mbedtls_ssl_setup(&ssl, &conf)) != 0)
    {
        printf(" failed\n  ! mbedtls_ssl_setup returned %d\n\n", ret);
        goto exit;
    }

    if ((ret = mbedtls_ssl_set_hostname(&ssl, endpoint)) != 0)
    {
        printf(" failed\n  ! mbedtls_ssl_set_hostname returned %d\n\n", ret);
        goto exit;
    }

    /* Start the connection */
    printf("  . Connecting to tcp/%s/%s...", endpoint, port);
    fflush(stdout);

    if ((ret = mbedtls_net_connect(&server_fd, endpoint, port, MBEDTLS_NET_PROTO_TCP)) != 0)
    {
        printf(" failed\n  ! mbedtls_net_connect returned %d\n\n", ret);
        goto exit;
    }

    printf(" ok\n");

    /* Attach the open handle to the ssl context */
    mbedtls_ssl_set_bio(&ssl, &server_fd, mbedtls_net_send, mbedtls_net_recv, NULL);

    /* Start the tls handshake (opens the socket itself) */
    printf("  . Performing the SSL/TLS handshake...");
    fflush(stdout);

    while ((ret = mbedtls_ssl_handshake(&ssl)) != 0)
    {
        if (ret != MBEDTLS_ERR_SSL_WANT_READ && ret != MBEDTLS_ERR_SSL_WANT_WRITE)
        {
            printf(" failed\n  ! mbedtls_ssl_handshake returned -0x%x\n\n", -ret);
            printf("Cipher Suite: %s\n", mbedtls_ssl_get_ciphersuite(&ssl));
            peer = mbedtls_ssl_get_peer_cert(&ssl);
            mbedtls_x509_crt_info(out, sizeof(out), NULL, peer);
            printf("Server Certificate Info:\n%s\n", out);
            fflush(stdout);
            goto exit;
        }
    }
    printf(" ok\n\n");


    printf("TLS Session Established and a Socket is ready for an Application\n");
    printf("Cipher Suite: %s\n", mbedtls_ssl_get_ciphersuite(&ssl));
    peer = mbedtls_ssl_get_peer_cert(&ssl);
    mbedtls_x509_crt_info(out, sizeof(out), NULL, peer);
    printf("Server Certificate Info:\n%s\n", out);
    fflush(stdout);

    /* In real life, we probably want to bail out when ret != 0 */
    uint32_t flags;
    if( ( flags = mbedtls_ssl_get_verify_result( &ssl ) ) != 0 )
    {
        char vrfy_buf[512];

        mbedtls_printf( " failed\n" );

        mbedtls_x509_crt_verify_info( vrfy_buf, sizeof( vrfy_buf ), "  ! ", flags );

        mbedtls_printf( "%s\n", vrfy_buf );
    }
    else
        mbedtls_printf( "SSL Server Verification Success!\n\n" );  
    /* @TODO: Insert application here to interact with the now open TLS socket */

    /* Write something to the new socket */
#if 0 
    int len;
    unsigned char buf[4096];
    
    len = sprintf((char*)buf, GET_REQUEST);
    while((ret = mbedtls_ssl_write(&ssl, buf, len)) <= 0);
    len = ret;
    printf("%d bytes written\n%s", len, (char *) buf );
    do
    {
        len = sizeof(buf)-1;
        memset(buf, 0, sizeof(buf));
        ret = mbedtls_ssl_read(&ssl, buf, len);

        if(ret <= 0)
        {
            printf("Nothing was read. Closing.\n");
            break;
        }

        len = ret;
        printf("%d bytes read\n%s\n", len, (char*)buf);
        fflush(stdout);
        break;
    }
    while(1);
#endif 
    // Start closing the connection
    mbedtls_ssl_close_notify(&ssl);

exit:

    mbedtls_net_free(&server_fd);

    mbedtls_x509_crt_free(&cacert);
    mbedtls_ssl_free(&ssl);
    mbedtls_ssl_config_free(&conf);
    mbedtls_ctr_drbg_free(&ctr_drbg);
    mbedtls_entropy_free(&entropy);

    return ret;
}
#endif 
// Stub implementations of mbedtls running on an ATEC device 

ATEC_MBED_Op_e ATEC_Mbed_Connect( NetworkContext_t * pNetworkContext,
                                 const ServerInfo_t * pServerInfo,
                                 uint32_t sendTimeoutMs,
                                 uint32_t recvTimeoutMs )
{
	return ATEC_MBED_OP_FAILURE;
}                                 


ATEC_MBED_Op_e ATEC_Mbed_Disconnect( const NetworkContext_t * pNetworkContext )
{
	return ATEC_MBED_OP_FAILURE;
}


int32_t ATEC_Mbed_Recv( const NetworkContext_t * pNetworkContext,
                      void * pBuffer,
                      size_t bytesToRecv )
{
	return 0; 
}           


int32_t ATEC_Mbed_Send( const NetworkContext_t * pNetworkContext,
                      const void * pBuffer,
                      size_t bytesToSend )
{
	return 0; 
}                                 
